#include 
#

// zdefiniujê du¿o za duzy bufor - z³a praktyka

#define SIZE 64


#define VALID_BINARY_CHAR(c) ( (c == '0') || (c == '1') )

#define WHITE_CHAR(c) ( (c == '\t') || (c == '\r') || (c == '\n') || (c == ' ') )


int main(int argc, char *argv[])

{

  int i = 0;

  int result = 0;

  char buf[SIZE];


  gets(buf); // potencjalne przepe³nienie bufora i iniekcja kodu - z³a praktyka

  buf[SIZE - 1] = '\0';


  for (i = 0; (i < SIZE) && (VALID_BINARY_CHAR(buf[i])) && (!WHITE_CHAR(buf[i])); ++i)

  {

    if ((result << 1) < result)

    {

      // przepe³nienie arytmetyczne - obs³u¿ b³¹d

      printf("Przepe³nienie arytmetyczne\n");

      return 1; // wiêcej ni¿ dwa punkty w których opuszcza siê funkcjê - z³y nawyk

    }

    result <<= 1; // pomnó¿ przez dwa

    result += (buf[i] == '1' ? 1 : 0);

  }


  // zmienna result zawiera wynik

  printf("%d\n", result);


  return 0;

}